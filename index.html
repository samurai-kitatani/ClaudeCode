<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>ã‚«ã‚¿ãƒ³ AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #8B4513 0%, #D2691E 100%);
            min-height: 100vh;
            padding-bottom: 70px;
        }

        .container {
            background: white;
            min-height: 100vh;
            max-width: 600px;
            margin: 0 auto;
            position: relative;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #8B4513 0%, #A0522D 100%);
            color: white;
            padding: 15px 20px;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .header h1 {
            font-size: clamp(1.3em, 5vw, 1.6em);
            margin-bottom: 5px;
        }

        .voice-toggle {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255,255,255,0.3);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            cursor: pointer;
        }

        .voice-toggle.on {
            background: #27ae60;
        }

        .voice-input-btn {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.4);
            width: 100%;
            max-width: 300px;
            margin: 10px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .voice-input-btn.listening {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
            animation: pulse-mic 1.5s infinite;
        }

        @keyframes pulse-mic {
            0%, 100% { box-shadow: 0 5px 15px rgba(39, 174, 96, 0.4); }
            50% { box-shadow: 0 5px 25px rgba(39, 174, 96, 0.8); }
        }

        .voice-status {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            min-height: 40px;
            text-align: center;
            color: #6c757d;
            font-size: 0.9em;
        }

        .voice-help {
            background: #e3f2fd;
            padding: 12px;
            border-radius: 8px;
            margin: 15px 0;
            font-size: 0.85em;
            color: #1976d2;
            border-left: 4px solid #2196f3;
        }

        /* Tab Navigation */
        .tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
        }

        .tab {
            flex: 1;
            padding: 15px;
            text-align: center;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            color: #6c757d;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }

        .tab.active {
            color: #8B4513;
            border-bottom-color: #8B4513;
            background: white;
        }

        /* Tab Content */
        .tab-content {
            display: none;
            padding: 20px;
        }

        .tab-content.active {
            display: block;
        }

        /* Dice Section */
        .current-player {
            background: linear-gradient(135deg, #f39c12 0%, #d68910 100%);
            color: white;
            padding: 12px 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 1.3em;
            font-weight: bold;
            text-align: center;
        }

        .dice-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
        }

        .dice {
            width: clamp(80px, 22vw, 100px);
            height: clamp(80px, 22vw, 100px);
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(35px, 10vw, 50px);
            font-weight: bold;
            color: white;
            box-shadow: 0 6px 15px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: transform 0.1s;
        }

        .dice:active { transform: scale(0.95); }
        .dice.red { background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); }
        .dice.yellow { background: linear-gradient(135deg, #f39c12 0%, #d68910 100%); }

        .dice.rolling {
            animation: roll 0.5s ease-in-out;
        }

        @keyframes roll {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(90deg) scale(0.9); }
            50% { transform: rotate(180deg) scale(1.1); }
            75% { transform: rotate(270deg) scale(0.9); }
        }

        .result {
            text-align: center;
            font-size: 2em;
            font-weight: bold;
            color: #333;
            margin: 20px 0;
        }

        .result.robber {
            color: #e74c3c;
            animation: pulse 0.5s;
        }

        @keyframes pulse {
            50% { transform: scale(1.1); }
        }

        .distribution {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            min-height: 80px;
        }

        .distribution h3 {
            color: #495057;
            font-size: 1.1em;
            margin-bottom: 10px;
        }

        .distribution-item {
            padding: 8px;
            margin: 5px 0;
            background: white;
            border-radius: 5px;
            border-left: 4px solid #CD853F;
        }

        button {
            background: linear-gradient(135deg, #CD853F 0%, #DAA520 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.1em;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            max-width: 300px;
            margin: 10px auto;
            display: block;
            box-shadow: 0 4px 10px rgba(205, 133, 63, 0.3);
        }

        button:active {
            transform: scale(0.98);
        }

        /* Map Section */
        .map-form {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
        }

        .form-group {
            margin-bottom: 10px;
        }

        .form-group label {
            display: block;
            color: #495057;
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .form-group select,
        .form-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 5px;
            font-size: 1em;
        }

        .tile-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .tile-item {
            background: white;
            padding: 12px;
            margin: 8px 0;
            border-radius: 8px;
            border-left: 4px solid #CD853F;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tile-info {
            flex: 1;
        }

        .tile-delete {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
        }

        /* Score Section */
        .score-board {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
        }

        .player-score {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid #CD853F;
        }

        .player-score.winner {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            color: white;
            animation: celebrate 1s infinite;
        }

        @keyframes celebrate {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .score-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            align-items: center;
        }

        .score-btn {
            width: 40px;
            height: 40px;
            padding: 0;
            font-size: 1.2em;
            border-radius: 50%;
            min-width: unset;
        }

        .score-display {
            font-size: 1.5em;
            font-weight: bold;
            text-align: center;
            flex: 1;
        }

        .special-cards {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .special-card {
            flex: 1;
            padding: 8px;
            background: #e9ecef;
            border: 2px solid #dee2e6;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            font-size: 0.85em;
            transition: all 0.3s;
        }

        .special-card.active {
            background: #CD853F;
            color: white;
            border-color: #CD853F;
        }

        /* Setup Screen */
        .setup-screen {
            padding: 20px;
            text-align: center;
        }

        .setup-screen h2 {
            color: #333;
            margin-bottom: 20px;
        }

        .player-count-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        .player-count-btn {
            padding: 12px 20px;
            background: white;
            border: 3px solid #8B4513;
            border-radius: 10px;
            font-size: 1em;
            font-weight: bold;
            color: #8B4513;
            cursor: pointer;
        }

        .player-count-btn.selected {
            background: #CD853F;
            color: white;
            border-color: #CD853F;
        }

        .player-inputs {
            margin: 20px 0;
        }

        .player-input {
            margin: 10px 0;
        }

        .player-input input {
            width: 100%;
            max-width: 300px;
            padding: 12px;
            border: 2px solid #8B4513;
            border-radius: 8px;
            font-size: 1em;
        }

        .hidden {
            display: none !important;
        }

        /* Resource Colors */
        .resource-wood { background-color: #8b4513; color: white; }
        .resource-brick { background-color: #cd5c5c; color: white; }
        .resource-wheat { background-color: #f0e68c; color: #333; }
        .resource-sheep { background-color: #90ee90; color: #333; }
        .resource-ore { background-color: #808080; color: white; }

        /* Mobile Optimization */
        @media (max-width: 600px) {
            body {
                padding-bottom: 50px;
            }

            .header {
                padding: 10px 15px;
            }

            .header h1 {
                font-size: 1.2em;
                margin-bottom: 3px;
            }

            .tab {
                padding: 12px 8px;
                font-size: 0.9em;
            }

            .tab-content {
                padding: 12px;
            }

            .current-player {
                padding: 8px 15px;
                margin-bottom: 12px;
                font-size: 1.1em;
            }

            .dice-container {
                gap: 15px;
                margin: 15px 0;
            }

            .dice {
                width: clamp(70px, 20vw, 85px);
                height: clamp(70px, 20vw, 85px);
                font-size: clamp(30px, 9vw, 40px);
            }

            .result {
                font-size: 1.5em;
                margin: 12px 0;
            }

            .distribution {
                padding: 10px;
                margin: 12px 0;
                min-height: 60px;
            }

            .distribution h3 {
                font-size: 0.95em;
                margin-bottom: 6px;
            }

            .distribution-item {
                padding: 6px;
                margin: 4px 0;
                font-size: 0.9em;
            }

            .voice-status, .voice-help {
                padding: 8px;
                margin: 8px 0;
                font-size: 0.8em;
            }

            button {
                padding: 12px 20px;
                font-size: 1em;
                margin: 8px auto;
            }

            .player-score {
                padding: 10px;
                margin: 8px 0;
            }

            .player-score .score-display {
                font-size: 1.3em;
            }

            .player-score > div:nth-child(3) {
                padding: 8px;
                font-size: 0.85em;
            }

            .player-score > div:nth-child(3) > div {
                margin: 2px 0 !important;
            }

            .score-controls {
                margin-top: 8px;
            }

            .special-cards {
                margin-top: 8px;
            }

            .special-card {
                padding: 6px;
                font-size: 0.75em;
            }

            .tile-item {
                padding: 8px;
                margin: 6px 0;
                font-size: 0.9em;
            }

            .tile-delete {
                padding: 6px 12px;
                font-size: 0.85em;
            }

            .map-form {
                padding: 12px;
                margin-bottom: 15px;
            }

            .form-group label {
                font-size: 0.85em;
                margin-bottom: 4px;
            }

            .form-group select,
            .form-group input {
                padding: 8px;
                font-size: 0.95em;
            }

            /* Compact score ranking */
            #playScoreRanking > div {
                padding: 6px !important;
                margin: 3px 0 !important;
                font-size: 0.85em !important;
            }

            /* Compact player settings inputs */
            .player-input input {
                padding: 8px !important;
                font-size: 0.9em !important;
            }

            .voice-toggle {
                top: 12px;
                right: 12px;
                padding: 6px 10px;
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Setup Screen -->
        <div class="setup-screen" id="setupScreen">
            <h1>ğŸ¤– ã‚«ã‚¿ãƒ³ AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ</h1>
            <h2>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®š</h2>
            <p>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼äººæ•°ã‚’é¸æŠï¼š</p>
            <div class="player-count-selector">
                <button class="player-count-btn" onclick="selectPlayerCount(2, this)">2äºº</button>
                <button class="player-count-btn" onclick="selectPlayerCount(3, this)">3äºº</button>
                <button class="player-count-btn selected" onclick="selectPlayerCount(4, this)">4äºº</button>
                <button class="player-count-btn" onclick="selectPlayerCount(5, this)">5äºº</button>
                <button class="player-count-btn" onclick="selectPlayerCount(6, this)">6äºº</button>
            </div>
            <div class="player-inputs" id="playerInputs"></div>
            <button onclick="startGame()">ğŸ® ã‚²ãƒ¼ãƒ é–‹å§‹</button>
        </div>

        <!-- Main Game Screen -->
        <div id="gameScreen" class="hidden">
            <!-- Header -->
            <div class="header">
                <h1>ğŸ¤– ã‚«ã‚¿ãƒ³ AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ</h1>
                <button class="voice-toggle" id="voiceToggle" onclick="toggleVoice()">ğŸ”‡ éŸ³å£°OFF</button>
            </div>

            <!-- Tabs -->
            <div class="tabs">
                <button class="tab active" onclick="switchTab('play', event)">Play</button>
                <button class="tab" onclick="switchTab('map', event)">Map</button>
                <button class="tab" onclick="switchTab('score', event)">Score</button>
            </div>

            <!-- Play Tab -->
            <div class="tab-content active" id="playTab">
                <div class="current-player" id="currentPlayer"></div>
                <div class="dice-container">
                    <div class="dice red" id="dice1" onclick="rollDice()">?</div>
                    <div class="dice yellow" id="dice2" onclick="rollDice()">?</div>
                </div>
                <div class="result" id="result">â€”</div>
                <div class="distribution" id="distribution">
                    <h3>è³‡æºé…å¸ƒ</h3>
                    <p style="color:#6c757d;">ã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã£ã¦ãã ã•ã„</p>
                </div>

                <!-- Score Ranking -->
                <div style="background:#f8f9fa;border-radius:10px;padding:12px;margin:15px 0;">
                    <h3 style="margin-bottom:8px;color:#495057;font-size:1em;">ğŸ† ã‚¹ã‚³ã‚¢ãƒ©ãƒ³ã‚­ãƒ³ã‚°</h3>
                    <div id="playScoreRanking"></div>
                </div>

                <div class="voice-status" style="background:#e8f5e9;border:2px solid #4caf50;">
                    ğŸ¤ éŸ³å£°å…¥åŠ› å¸¸æ™‚ON - ã€Œã‚µã‚¤ã‚³ãƒ­ã€ã€ŒæŒ¯ã‚‹ã€ã¾ãŸã¯ã€Œç•ªå·ï¼‹è³‡æºï¼‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‹ç¨®é¡ã€ã§ç™»éŒ²
                </div>
                <button onclick="rollDice()">ã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã‚‹</button>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;">
                    <button onclick="previousPlayer()" style="background:#95a5a6;">â¬…ï¸ å‰ã®äºº</button>
                    <button onclick="nextPlayer()" style="background:#6c757d;">æ¬¡ã®äºº â¡ï¸</button>
                </div>
                <button onclick="showPlayerSettings()" style="background:#e67e22;margin-top:10px;">âš™ï¸ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®š</button>
            </div>

            <!-- Map Tab -->
            <div class="tab-content" id="mapTab">
                <h2 style="margin-bottom:15px;">ğŸ—ºï¸ ãƒãƒƒãƒ—çŠ¶æ³</h2>
                <div class="voice-help" style="background:#e8f5e9;border:2px solid #4caf50;margin-bottom:20px;">
                    ğŸ¤ éŸ³å£°å…¥åŠ› å¸¸æ™‚ON<br>
                    ğŸ“¢ ä¾‹: ã€Œ8ç•ªã€æœ¨ã€èµ¤ã€é–‹æ‹“åœ°ã€ã€Œ6ç•ªã€éº¦ã€é’ã€éƒ½å¸‚ã€
                </div>
                <!-- Hidden form elements for addTile() function -->
                <select id="tileNumber" style="display:none;">
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="8">8</option>
                    <option value="9">9</option>
                    <option value="10">10</option>
                    <option value="11">11</option>
                    <option value="12">12</option>
                </select>
                <select id="tileResource" style="display:none;">
                    <option value="wood">æœ¨</option>
                    <option value="brick">åœŸ</option>
                    <option value="wheat">éº¦</option>
                    <option value="sheep">ç¾Š</option>
                    <option value="ore">çŸ³</option>
                </select>
                <select id="tilePlayer" style="display:none;"></select>
                <select id="tileType" style="display:none;">
                    <option value="settlement">é–‹æ‹“åœ°</option>
                    <option value="city">éƒ½å¸‚</option>
                </select>
                <h3 style="margin-bottom:10px;">ğŸ“ ç™»éŒ²æ¸ˆã¿åœŸåœ°</h3>
                <div class="tile-list" id="tileList"></div>
            </div>

            <!-- Score Tab -->
            <div class="tab-content" id="scoreTab">
                <h2 style="margin-bottom:15px;">ã‚¹ã‚³ã‚¢ãƒœãƒ¼ãƒ‰</h2>
                <div class="score-board" id="scoreBoard"></div>
                <button onclick="resetScores()" style="background:#e74c3c;margin-top:20px;">ã‚¹ã‚³ã‚¢ãƒªã‚»ãƒƒãƒˆ</button>
            </div>
        </div>
    </div>

    <script>
        // Game State
        let players = [];
        let currentPlayerIndex = 0;
        let playerCount = 4;
        let tiles = [];
        let scores = {};
        let voiceEnabled = false;
        let isRolling = false;
        let recognition = null;
        let voiceRecognitionActive = false;

        // Resource Names
        const resources = {
            wood: { name: 'æœ¨', color: '#8b4513', icon: 'ğŸŒ²' },
            brick: { name: 'åœŸ', color: '#cd5c5c', icon: 'ğŸ§±' },
            wheat: { name: 'éº¦', color: '#f0e68c', icon: 'ğŸŒ¾' },
            sheep: { name: 'ç¾Š', color: '#90ee90', icon: 'ğŸ‘' },
            ore: { name: 'çŸ³', color: '#808080', icon: 'â›°ï¸' }
        };

        // Player Colors
        const playerColors = {
            red: { name: 'èµ¤', hex: '#e74c3c' },
            blue: { name: 'é’', hex: '#3498db' },
            white: { name: 'ç™½', hex: '#95a5a6' },  // Changed to gray for visibility
            orange: { name: 'ã‚ªãƒ¬ãƒ³ã‚¸', hex: '#f39c12' }
        };

        // Initialize
        function initPlayerSetup() {
            selectPlayerCount(4);
        }

        function selectPlayerCount(count, target = null) {
            playerCount = count;
            document.querySelectorAll('.player-count-btn').forEach((btn, index) => {
                btn.classList.remove('selected');
                if (!target && index === 2) btn.classList.add('selected');
            });
            if (target) target.classList.add('selected');

            // Load saved player names from localStorage
            const savedPlayers = JSON.parse(localStorage.getItem('catanPlayers') || '{}');

            const playerInputsDiv = document.getElementById('playerInputs');
            playerInputsDiv.innerHTML = '';

            const fixedColors = [
                { key: 'red', label: 'èµ¤' },
                { key: 'blue', label: 'é’' },
                { key: 'white', label: 'ç™½' },
                { key: 'orange', label: 'ã‚ªãƒ¬ãƒ³ã‚¸' }
            ];

            for (let i = 0; i < count; i++) {
                const playerKey = `player${i + 1}`;
                const savedName = savedPlayers[playerKey] || '';
                const colorInfo = fixedColors[i % 4];
                const colorHex = playerColors[colorInfo.key].hex;

                const inputDiv = document.createElement('div');
                inputDiv.className = 'player-input';
                inputDiv.innerHTML = `
                    <div style="display:flex;gap:10px;align-items:center;">
                        <div style="width:80px;padding:10px;background:${colorHex};color:${colorInfo.key === 'white' ? '#333' : 'white'};border-radius:5px;text-align:center;font-weight:bold;font-size:0.9em;">
                            ${colorInfo.label}
                        </div>
                        <input type="text" id="player${i + 1}" data-color="${colorInfo.key}" data-order="${i}"
                               placeholder="${colorInfo.label}ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼"
                               value="${savedName}"
                               onfocus="if(this.value===this.placeholder) this.value='';"
                               style="flex:1;padding:10px;border:2px solid ${colorHex};border-radius:5px;">
                        <div style="display:flex;gap:3px;">
                            ${Array.from({length: count}, (_, idx) =>
                                `<button onclick="setPlayerOrder(${i}, ${idx})" id="orderBtn${i}_${idx}"
                                 style="width:28px;height:28px;padding:0;font-size:0.8em;background:${idx === i ? '#CD853F' : '#ecf0f1'};color:${idx === i ? 'white' : '#333'};border:none;border-radius:5px;font-weight:bold;">${idx + 1}</button>`
                            ).join('')}
                        </div>
                    </div>
                `;
                playerInputsDiv.appendChild(inputDiv);
            }
        }

        function setPlayerOrder(playerIndex, newOrder) {
            const inputs = document.querySelectorAll('#playerInputs input[type="text"]');
            const playerCount = inputs.length;

            // Get all current values
            const values = Array.from(inputs).map(input => input.value);
            const colors = Array.from(inputs).map(input => input.dataset.color);

            // Get current order
            const currentOrder = parseInt(inputs[playerIndex].dataset.order);

            if (currentOrder === newOrder) return;

            // Swap players
            const tempValue = values[playerIndex];
            const tempColor = colors[playerIndex];

            if (newOrder > currentOrder) {
                // Move down
                for (let i = playerIndex; i < newOrder; i++) {
                    values[i] = values[i + 1];
                    colors[i] = colors[i + 1];
                }
            } else {
                // Move up
                for (let i = playerIndex; i > newOrder; i--) {
                    values[i] = values[i - 1];
                    colors[i] = colors[i - 1];
                }
            }

            values[newOrder] = tempValue;
            colors[newOrder] = tempColor;

            // Update all inputs
            inputs.forEach((input, i) => {
                input.value = values[i];
                input.dataset.color = colors[i];
                input.dataset.order = i;
            });

            // Update button styles
            for (let i = 0; i < playerCount; i++) {
                for (let j = 0; j < playerCount; j++) {
                    const btn = document.getElementById(`orderBtn${i}_${j}`);
                    if (btn) {
                        const isSelected = i === j;
                        btn.style.background = isSelected ? '#CD853F' : '#ecf0f1';
                        btn.style.color = isSelected ? 'white' : '#333';
                    }
                }
            }
        }

        function startGame() {
            players = [];
            const playerColorMap = {};
            const savedPlayers = {};

            const fixedColors = ['red', 'blue', 'white', 'orange'];

            for (let i = 0; i < playerCount; i++) {
                const input = document.getElementById(`player${i + 1}`);
                const inputVal = input.value.trim();
                const colorKey = fixedColors[i % 4];
                const name = inputVal || `${playerColors[colorKey].name}ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼`;

                players.push(name);
                playerColorMap[name] = playerColors[colorKey].hex;

                // Save to localStorage
                savedPlayers[`player${i + 1}`] = inputVal;
            }

            // Save player names
            localStorage.setItem('catanPlayers', JSON.stringify(savedPlayers));

            currentPlayerIndex = 0;

            // Initialize scores with extended data (start with 1 point)
            scores = {};
            players.forEach(player => {
                scores[player] = {
                    manual: 1,
                    roads: 0,
                    knights: 0,
                    developmentCards: 0,
                    longestRoad: false,
                    largestArmy: false,
                    color: playerColorMap[player]
                };
            });

            // Reset tiles for new game
            tiles = [];

            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.remove('hidden');

            updatePlayerDropdown();
            updateCurrentPlayer();
            updateScoreBoard();
            speak(`${players[currentPlayerIndex]}ã•ã‚“ã€ã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã£ã¦ãã ã•ã„ï¼`);

            // Start voice recognition
            startVoiceRecognition();
        }

        function updatePlayerDropdown() {
            const select = document.getElementById('tilePlayer');
            select.innerHTML = players.map(p => `<option value="${p}">${p}</option>`).join('');
        }

        function updateCurrentPlayer() {
            const currentColor = scores[players[currentPlayerIndex]]?.color || '#667eea';
            document.getElementById('currentPlayer').textContent = `${players[currentPlayerIndex]}ã•ã‚“ã®ã°ã‚“`;
            document.getElementById('currentPlayer').style.background = `linear-gradient(135deg, ${currentColor} 0%, ${adjustColor(currentColor, -20)} 100%)`;
            updatePlayScoreRanking();
        }

        function adjustColor(color, percent) {
            const num = parseInt(color.replace("#",""), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 +
                (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255))
                .toString(16).slice(1);
        }

        function updatePlayScoreRanking() {
            const ranking = players.map(player => {
                const score = scores[player];
                const basePoints = tiles.filter(t => t.player === player).reduce((sum, t) =>
                    sum + (t.type === 'city' ? 2 : 1), 0
                );
                const bonusPoints = (score.longestRoad ? 2 : 0) + (score.largestArmy ? 2 : 0);
                const total = basePoints + score.manual + bonusPoints;
                return { player, total, color: score.color };
            }).sort((a, b) => b.total - a.total);

            const rankingHtml = ranking.map((item, index) => `
                <div style="display:flex;justify-content:space-between;padding:8px;margin:5px 0;background:white;border-radius:5px;border-left:4px solid ${item.color};">
                    <span><strong>${index + 1}ä½</strong> ${item.player}</span>
                    <span style="font-weight:bold;color:${item.color};">${item.total}ç‚¹</span>
                </div>
            `).join('');

            document.getElementById('playScoreRanking').innerHTML = rankingHtml;
        }

        function nextPlayer() {
            currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
            updateCurrentPlayer();
            speak(`${players[currentPlayerIndex]}ã•ã‚“ã€ã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã£ã¦ãã ã•ã„ï¼`);
        }

        // Dice Roll
        function rollDice() {
            if (isRolling) return;
            isRolling = true;

            const dice1 = document.getElementById('dice1');
            const dice2 = document.getElementById('dice2');
            const result = document.getElementById('result');

            dice1.classList.add('rolling');
            dice2.classList.add('rolling');

            let counter = 0;
            const animationInterval = setInterval(() => {
                dice1.textContent = Math.floor(Math.random() * 6) + 1;
                dice2.textContent = Math.floor(Math.random() * 6) + 1;
                counter++;
                if (counter >= 10) clearInterval(animationInterval);
            }, 50);

            setTimeout(() => {
                const value1 = Math.floor(Math.random() * 6) + 1;
                const value2 = Math.floor(Math.random() * 6) + 1;
                const total = value1 + value2;

                dice1.textContent = value1;
                dice2.textContent = value2;
                dice1.classList.remove('rolling');
                dice2.classList.remove('rolling');

                result.textContent = `åˆè¨ˆ: ${total}`;
                result.classList.toggle('robber', total === 7);

                if (total === 7) {
                    showDistribution(null, true);
                    speak(`${total}ã€ç›—è³ŠãŒæ¥ã¾ã—ãŸï¼æ‰‹æœ­8æšä»¥ä¸Šã¯ãƒãƒ¼ã‚¹ãƒˆã§ã™`);
                } else {
                    const distribution = calculateDistribution(total);
                    showDistribution(distribution);
                    speakDistribution(total, distribution);
                }

                updatePlayScoreRanking();
                isRolling = false;
            }, 500);
        }

        function calculateDistribution(number) {
            const distribution = {};
            tiles.filter(t => t.number === number).forEach(tile => {
                if (!distribution[tile.player]) distribution[tile.player] = {};
                const resource = tile.resource;
                const amount = tile.type === 'city' ? 2 : 1;
                distribution[tile.player][resource] = (distribution[tile.player][resource] || 0) + amount;
            });
            return distribution;
        }

        function showDistribution(distribution, isRobber = false) {
            const div = document.getElementById('distribution');
            if (isRobber) {
                div.innerHTML = '<h3>è³‡æºé…å¸ƒ</h3><div style="color:#e74c3c;font-weight:bold;padding:10px;">âš ï¸ ç›—è³Šï¼è³‡æºãªã—</div>';
                return;
            }

            let html = '<h3>è³‡æºé…å¸ƒ</h3>';
            if (!distribution || Object.keys(distribution).length === 0) {
                html += '<p style="color:#6c757d;">é…å¸ƒãªã—</p>';
            } else {
                Object.entries(distribution).forEach(([player, resourceCounts]) => {
                    const items = Object.entries(resourceCounts).map(([res, amt]) => {
                        const icon = resources[res].icon;
                        const icons = icon.repeat(amt);
                        return `<span style="font-size:1.5em;">${icons}</span> <span style="font-size:0.9em;">${resources[res].name} Ã—${amt}</span>`;
                    }).join(' ');
                    html += `<div class="distribution-item"><strong>${player}:</strong> ${items}</div>`;
                });
            }
            div.innerHTML = html;
        }

        function speakDistribution(number, distribution) {
            if (!voiceEnabled) return;

            let text = `${number}ç•ªã€‚`;
            if (Object.keys(distribution).length === 0) {
                text += 'é…å¸ƒãªã—';
            } else {
                const parts = [];
                Object.entries(distribution).forEach(([player, playerResources]) => {
                    const items = Object.entries(playerResources).map(([res, amt]) =>
                        `${resources[res].name}ã‚’${amt}ã¤`
                    ).join('ã€');
                    parts.push(`${player}ã«${items}`);
                });
                text += parts.join('ã€‚');
            }
            speak(text);
        }

        // Map Management
        function addTile() {
            const tile = {
                number: parseInt(document.getElementById('tileNumber').value),
                resource: document.getElementById('tileResource').value,
                player: document.getElementById('tilePlayer').value,
                type: document.getElementById('tileType').value,
                id: Date.now()
            };
            tiles.push(tile);
            saveTiles();
            renderTileList();
            updatePlayScoreRanking();
            updateScoreBoard();
        }

        function deleteTile(id) {
            tiles = tiles.filter(t => t.id !== id);
            saveTiles();
            renderTileList();
            updatePlayScoreRanking();
            updateScoreBoard();
        }

        function renderTileList() {
            const list = document.getElementById('tileList');
            if (tiles.length === 0) {
                list.innerHTML = '<p style="color:#6c757d;text-align:center;padding:20px;">ğŸ¤ éŸ³å£°ã§åœŸåœ°ã‚’ç™»éŒ²ã—ã¦ãã ã•ã„</p>';
                return;
            }

            // Group by player
            const tilesByPlayer = {};
            players.forEach(p => tilesByPlayer[p] = []);
            tiles.forEach(tile => {
                if (tilesByPlayer[tile.player]) {
                    tilesByPlayer[tile.player].push(tile);
                }
            });

            const fixedColors = ['red', 'blue', 'white', 'orange'];
            list.innerHTML = players.map((player, playerIndex) => {
                const playerTiles = tilesByPlayer[player] || [];
                if (playerTiles.length === 0) return '';

                const colorKey = fixedColors[playerIndex % 4];
                const colorHex = playerColors[colorKey].hex;

                return `
                    <div style="margin-bottom:20px;">
                        <div style="background:${colorHex};color:${colorKey === 'white' ? '#333' : 'white'};padding:10px;border-radius:5px;font-weight:bold;margin-bottom:8px;">
                            ${player} ã®åœŸåœ° (${playerTiles.length}ç®‡æ‰€)
                        </div>
                        ${playerTiles.map(tile => `
                            <div class="tile-item" style="border-left-color:${colorHex};">
                                <div class="tile-info" style="display:flex;align-items:center;gap:8px;">
                                    <span style="font-size:1.3em;min-width:35px;text-align:center;background:#f8f9fa;padding:3px 6px;border-radius:4px;font-weight:bold;">${tile.number}</span>
                                    <span style="font-size:1.5em;">${resources[tile.resource].icon}</span>
                                    <span style="font-size:0.9em;color:#6c757d;">${resources[tile.resource].name}</span>
                                    <span style="font-size:1.2em;">${tile.type === 'city' ? 'ğŸ›ï¸' : 'ğŸ '}</span>
                                    <span style="font-size:0.85em;color:#6c757d;">${tile.type === 'city' ? 'éƒ½å¸‚' : 'é–‹æ‹“åœ°'}</span>
                                </div>
                                <button class="tile-delete" onclick="deleteTile(${tile.id})">å‰Šé™¤</button>
                            </div>
                        `).join('')}
                    </div>
                `;
            }).join('');
        }

        function saveTiles() {
            localStorage.setItem('catanTiles', JSON.stringify(tiles));
        }

        // Score Management
        function updateScoreBoard() {
            const board = document.getElementById('scoreBoard');
            board.innerHTML = players.map(player => {
                const score = scores[player];
                const playerTiles = tiles.filter(t => t.player === player);
                const settlements = playerTiles.filter(t => t.type === 'settlement').length;
                const cities = playerTiles.filter(t => t.type === 'city').length;
                const basePoints = settlements + cities * 2;
                const bonusPoints = (score.longestRoad ? 2 : 0) + (score.largestArmy ? 2 : 0);
                const total = basePoints + score.manual + bonusPoints;
                const isWinner = total >= 10;

                return `
                    <div class="player-score ${isWinner ? 'winner' : ''}" style="border-left-color:${score.color};">
                        <div style="display:flex;justify-content:space-between;align-items:center;">
                            <strong style="font-size:1.3em;">${player}</strong>
                            <div style="display:flex;align-items:center;gap:10px;">
                                <div class="score-display" style="font-size:2em;margin:0;">${total}ç‚¹</div>
                                ${isWinner ? '<span style="font-size:1.5em;">ğŸ†</span>' : ''}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            // Check for winner
            const winner = players.find(p => {
                const score = scores[p];
                const base = tiles.filter(t => t.player === p).reduce((s, t) => s + (t.type === 'city' ? 2 : 1), 0);
                const bonus = (score.longestRoad ? 2 : 0) + (score.largestArmy ? 2 : 0);
                return base + score.manual + bonus >= 10;
            });

            if (winner) speak(`${winner}ã•ã‚“ãŒå‹åˆ©ã—ã¾ã—ãŸï¼ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼`);
        }

        function adjustScore(player, amount) {
            scores[player].manual = Math.max(0, scores[player].manual + amount);
            updateScoreBoard();
        }

        function toggleSpecial(player, type) {
            // Only one player can have each special card
            if (!scores[player][type]) {
                players.forEach(p => scores[p][type] = false);
            }
            scores[player][type] = !scores[player][type];
            updateScoreBoard();
        }

        function resetScores() {
            if (!confirm('ã‚¹ã‚³ã‚¢ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ')) return;
            const fixedColors = ['red', 'blue', 'white', 'orange'];
            players.forEach((p, i) => {
                const colorKey = fixedColors[i % 4];
                scores[p] = {
                    manual: 1,
                    roads: 0,
                    knights: 0,
                    developmentCards: 0,
                    longestRoad: false,
                    largestArmy: false,
                    color: playerColors[colorKey].hex
                };
            });
            updateScoreBoard();
        }

        // Voice
        function toggleVoice() {
            voiceEnabled = !voiceEnabled;
            const btn = document.getElementById('voiceToggle');
            btn.textContent = voiceEnabled ? 'ğŸ”Š éŸ³å£°ON' : 'ğŸ”‡ éŸ³å£°OFF';
            btn.classList.toggle('on', voiceEnabled);
        }

        function speak(text) {
            if (!voiceEnabled || !('speechSynthesis' in window)) return;
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'ja-JP';
            utterance.rate = 1.3; // Speed up to 1.3x (range: 0.1 to 10)
            window.speechSynthesis.speak(utterance);
        }

        // Voice Recognition
        function initVoiceRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.lang = 'ja-JP';
                recognition.continuous = true;
                recognition.interimResults = false;

                recognition.onresult = (event) => {
                    const lastResult = event.results[event.results.length - 1];
                    const transcript = lastResult[0].transcript;
                    handleVoiceInput(transcript);
                };

                recognition.onerror = (event) => {
                    console.error('éŸ³å£°èªè­˜ã‚¨ãƒ©ãƒ¼:', event.error);
                    if (event.error === 'no-speech' || event.error === 'audio-capture') {
                        // Automatically restart
                        setTimeout(() => {
                            if (voiceRecognitionActive) {
                                try { recognition.start(); } catch(e) {}
                            }
                        }, 1000);
                    }
                };

                recognition.onend = () => {
                    // Auto-restart if still active
                    if (voiceRecognitionActive) {
                        setTimeout(() => {
                            try { recognition.start(); } catch(e) {}
                        }, 500);
                    }
                };
            }
        }

        function startVoiceRecognition() {
            if (!recognition) initVoiceRecognition();
            if (recognition && !voiceRecognitionActive) {
                voiceRecognitionActive = true;
                try {
                    recognition.start();
                } catch(e) {
                    console.log('éŸ³å£°èªè­˜ã¯æ—¢ã«é–‹å§‹ã•ã‚Œã¦ã„ã¾ã™');
                }
            }
        }

        function stopVoiceRecognition() {
            voiceRecognitionActive = false;
            if (recognition) {
                try { recognition.stop(); } catch(e) {}
            }
        }

        function handleVoiceInput(text) {
            console.log('éŸ³å£°å…¥åŠ›:', text);
            const cleaned = text.replace(/\s/g, '');

            // Check for dice roll commands
            if (cleaned.includes('ã‚µã‚¤ã‚³ãƒ­') || cleaned.includes('ã•ã„ã“ã‚') ||
                cleaned.includes('æŒ¯ã‚‹') || cleaned.includes('ãµã‚‹') ||
                cleaned.includes('ãƒ€ã‚¤ã‚¹') || cleaned.includes('ãƒ­ãƒ¼ãƒ«')) {
                rollDice();
                speak('ã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã‚Šã¾ã—ãŸ');
                return;
            }

            // Check for player navigation
            if (cleaned.includes('æ¬¡') || cleaned.includes('ã¤ã') || cleaned.includes('ãƒã‚¯ã‚¹ãƒˆ')) {
                nextPlayer();
                return;
            }

            if (cleaned.includes('å‰') || cleaned.includes('ã¾ãˆ') || cleaned.includes('æˆ»') || cleaned.includes('ã‚‚ã©')) {
                previousPlayer();
                return;
            }

            // Try AI Voice Command (ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è‰² + ã‚¢ã‚¤ãƒ†ãƒ  + ã‚¢ã‚¯ã‚·ãƒ§ãƒ³)
            if (parseAIVoiceCommand(cleaned)) {
                return;
            }

            // Try to parse as tile registration
            // Format: "ç•ªå·ã€è³‡æºã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã€ç¨®é¡"
            if (cleaned.includes('ç•ª') || /\d+/.test(text)) {
                parseTileInput(text);
                return;
            }
        }

        function parseAIVoiceCommand(text) {
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è‰²ã‚’èªè­˜
            const colorMap = {
                'èµ¤': 0, 'ã‚ã‹': 0, 'ãƒ¬ãƒƒãƒ‰': 0,
                'é’': 1, 'ã‚ãŠ': 1, 'ãƒ–ãƒ«ãƒ¼': 1,
                'ç™½': 2, 'ã—ã‚': 2, 'ãƒ›ãƒ¯ã‚¤ãƒˆ': 2,
                'ã‚ªãƒ¬ãƒ³ã‚¸': 3, 'ãŠã‚Œã‚“ã˜': 3, 'æ©™': 3
            };

            let playerIndex = -1;
            for (const [key, index] of Object.entries(colorMap)) {
                if (text.includes(key)) {
                    playerIndex = index;
                    break;
                }
            }

            if (playerIndex === -1 || playerIndex >= players.length) {
                return false; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è‰²ãŒè¦‹ã¤ã‹ã‚‰ãªã„
            }

            const player = players[playerIndex];
            let action = null;
            let item = null;

            // ã‚¢ã‚¤ãƒ†ãƒ ã‚’èªè­˜
            if (text.includes('è¡—é“') || text.includes('é“') || text.includes('è³‡æ') || text.includes('äº¤æ˜“è·¯')) {
                item = 'roads';
            } else if (text.includes('é–‹æ‹“åœ°') || text.includes('å®¶') || text.includes('ã‹ã„ãŸãã¡')) {
                item = 'settlement';
            } else if (text.includes('éƒ½å¸‚') || text.includes('ãŠåŸ') || text.includes('åŸ') || text.includes('ã¨ã—')) {
                item = 'city';
            } else if (text.includes('é¨å£«') || text.includes('å…µéšŠ') || text.includes('ãƒŠã‚¤ãƒˆ') || text.includes('ãã—')) {
                item = 'knights';
            } else if (text.includes('ã‚«ãƒ¼ãƒ‰') || text.includes('ç™ºå±•') || text.includes('ã¯ã£ã¦ã‚“')) {
                item = 'developmentCards';
            }

            // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’èªè­˜
            if (text.includes('å¢—ã‚„ã™') || text.includes('ãƒ—ãƒ©ã‚¹') || text.includes('ä½œã£ãŸ') ||
                text.includes('å»ºè¨­') || text.includes('ãµã‚„ã™') || text.includes('+')) {
                action = 'add';
            } else if (text.includes('æ¸›ã‚‰ã™') || text.includes('ãƒã‚¤ãƒŠã‚¹') || text.includes('ã‚­ãƒ£ãƒ³ã‚»ãƒ«') ||
                       text.includes('ã¸ã‚‰ã™') || text.includes('-')) {
                action = 'subtract';
            } else if (text.includes('æœ€å¤§é¨å£«åŠ›') || text.includes('ãƒ©ãƒ¼ã‚¸ã‚¹ãƒˆ') || text.includes('æœ€å¤§')) {
                action = 'largestArmy';
            } else if (text.includes('æœ€é•·äº¤æ˜“è·¯') || text.includes('ãƒ­ãƒ³ã‚²ã‚¹ãƒˆ') || text.includes('æœ€é•·')) {
                action = 'longestRoad';
            }

            if (!action) return false;

            // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
            executeVoiceCommand(player, item, action);
            return true;
        }

        function executeVoiceCommand(player, item, action) {
            const fixedColors = ['red', 'blue', 'white', 'orange'];
            const playerIndex = players.indexOf(player);
            const colorLabel = playerColors[fixedColors[playerIndex % 4]].name;

            if (action === 'add') {
                if (item === 'roads') {
                    scores[player].roads++;
                    speak(`${colorLabel}ã®è¡—é“ã‚’å¢—ã‚„ã—ã¾ã—ãŸã€‚ç¾åœ¨${scores[player].roads}æœ¬ã§ã™`);
                } else if (item === 'settlement') {
                    // ãƒãƒƒãƒ—ã«é–‹æ‹“åœ°ã‚’ç™»éŒ²ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŒã€ã“ã“ã§ã¯ä»®å®Ÿè£…
                    speak(`${colorLabel}ã®é–‹æ‹“åœ°ã‚’ç™»éŒ²ã—ã¾ã™ã€‚Mapã‚¿ãƒ–ã§ç™»éŒ²ã—ã¦ãã ã•ã„`);
                } else if (item === 'city') {
                    speak(`${colorLabel}ã®éƒ½å¸‚ã‚’ç™»éŒ²ã—ã¾ã™ã€‚Mapã‚¿ãƒ–ã§ç™»éŒ²ã—ã¦ãã ã•ã„`);
                } else if (item === 'knights') {
                    scores[player].knights++;
                    speak(`${colorLabel}ã®é¨å£«ã‚’å¢—ã‚„ã—ã¾ã—ãŸã€‚ç¾åœ¨${scores[player].knights}æšã§ã™`);
                } else if (item === 'developmentCards') {
                    scores[player].developmentCards++;
                    speak(`${colorLabel}ã®ç™ºå±•ã‚«ãƒ¼ãƒ‰ã‚’å¢—ã‚„ã—ã¾ã—ãŸã€‚ç¾åœ¨${scores[player].developmentCards}æšã§ã™`);
                }
            } else if (action === 'subtract') {
                if (item === 'roads' && scores[player].roads > 0) {
                    scores[player].roads--;
                    speak(`${colorLabel}ã®è¡—é“ã‚’æ¸›ã‚‰ã—ã¾ã—ãŸã€‚ç¾åœ¨${scores[player].roads}æœ¬ã§ã™`);
                } else if (item === 'knights' && scores[player].knights > 0) {
                    scores[player].knights--;
                    speak(`${colorLabel}ã®é¨å£«ã‚’æ¸›ã‚‰ã—ã¾ã—ãŸã€‚ç¾åœ¨${scores[player].knights}æšã§ã™`);
                } else if (item === 'developmentCards' && scores[player].developmentCards > 0) {
                    scores[player].developmentCards--;
                    speak(`${colorLabel}ã®ç™ºå±•ã‚«ãƒ¼ãƒ‰ã‚’æ¸›ã‚‰ã—ã¾ã—ãŸã€‚ç¾åœ¨${scores[player].developmentCards}æšã§ã™`);
                }
            } else if (action === 'largestArmy') {
                players.forEach(p => scores[p].largestArmy = false);
                scores[player].largestArmy = true;
                speak(`${colorLabel}ãŒæœ€å¤§é¨å£«åŠ›ã‚’ç²å¾—ã—ã¾ã—ãŸ`);
            } else if (action === 'longestRoad') {
                players.forEach(p => scores[p].longestRoad = false);
                scores[player].longestRoad = true;
                speak(`${colorLabel}ãŒæœ€é•·äº¤æ˜“è·¯ã‚’ç²å¾—ã—ã¾ã—ãŸ`);
            }

            updateScoreBoard();
            updatePlayScoreRanking();
        }

        function parseTileInput(text) {
            // Parse input like "8ç•ªã€æœ¨ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1ã€é–‹æ‹“åœ°"
            const cleaned = text.replace(/\s/g, '');
            const parts = cleaned.split(/ã€|,|ã€‚/);

            console.log('éŸ³å£°ãƒ‘ãƒ¼ã‚¹:', parts);

            let parsedData = {
                number: null,
                resource: null,
                player: null,
                type: 'settlement'
            };

            let errors = [];

            // Extract number (must be 2-12, excluding 7)
            try {
                const numberMatch = cleaned.match(/(\d+)/);
                if (!numberMatch) throw new Error('æ•°å­—');
                const number = parseInt(numberMatch[1]);
                if (![2,3,4,5,6,8,9,10,11,12].includes(number)) {
                    throw new Error('æ•°å­—');
                }
                parsedData.number = number;
            } catch (e) {
                errors.push('æ•°å­—');
            }

            // Extract resource from anywhere in the text
            try {
                const resourceMap = {
                    'æœ¨': 'wood', 'ã': 'wood', 'ã‚‚ã': 'wood',
                    'åœŸ': 'brick', 'ã¤ã¡': 'brick', 'ãƒ¬ãƒ³ã‚¬': 'brick', 'ã‚Œã‚“ãŒ': 'brick',
                    'éº¦': 'wheat', 'ã‚€ã': 'wheat', 'ãƒ ã‚®': 'wheat', 'å°éº¦': 'wheat',
                    'ç¾Š': 'sheep', 'ã²ã¤ã˜': 'sheep', 'ãƒ’ãƒ„ã‚¸': 'sheep',
                    'çŸ³': 'ore', 'ã„ã—': 'ore', 'ã‚¤ã‚·': 'ore', 'é‰±çŸ³': 'ore'
                };
                let resource = null;
                for (const [key, value] of Object.entries(resourceMap)) {
                    if (cleaned.includes(key)) {
                        resource = value;
                        break;
                    }
                }
                if (!resource) throw new Error('è³‡æº');
                parsedData.resource = resource;
            } catch (e) {
                errors.push('è³‡æº');
            }

            // Extract player - check all parts
            try {
                let playerName = null;

                // Color map for player identification
                const colorToPlayerMap = {
                    'èµ¤': 0, 'ã‚ã‹': 0, 'ãƒ¬ãƒƒãƒ‰': 0,
                    'é’': 1, 'ã‚ãŠ': 1, 'ãƒ–ãƒ«ãƒ¼': 1,
                    'ç™½': 2, 'ã—ã‚': 2, 'ãƒ›ãƒ¯ã‚¤ãƒˆ': 2,
                    'ã‚ªãƒ¬ãƒ³ã‚¸': 3, 'ãŠã‚Œã‚“ã˜': 3, 'æ©™': 3
                };

                // Check for color names first
                for (const [colorName, playerIndex] of Object.entries(colorToPlayerMap)) {
                    if (cleaned.includes(colorName) && playerIndex < players.length) {
                        playerName = players[playerIndex];
                        break;
                    }
                }

                if (!playerName) {
                    for (const part of parts) {
                        // Direct match
                        for (const player of players) {
                            if (part.includes(player) || part.includes(player.replace('ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼', ''))) {
                                playerName = player;
                                break;
                            }
                        }
                        if (playerName) break;

                        // Number match (e.g., "1" means ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1)
                        const playerMatch = part.match(/(\d+)/);
                        if (playerMatch) {
                            const idx = parseInt(playerMatch[1]) - 1;
                            if (idx >= 0 && idx < players.length) {
                                playerName = players[idx];
                                break;
                            }
                        }
                    }
                }

                if (!playerName) {
                    // Default to current player
                    playerName = players[currentPlayerIndex];
                }
                parsedData.player = playerName;
            } catch (e) {
                errors.push('ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼');
            }

            // Extract type (default: settlement)
            if (cleaned.includes('éƒ½å¸‚') || cleaned.includes('ã¨ã—') || cleaned.includes('ãƒˆã‚·')) {
                parsedData.type = 'city';
            }

            // If all data parsed successfully, add tile
            if (errors.length === 0) {
                document.getElementById('tileNumber').value = parsedData.number;
                document.getElementById('tileResource').value = parsedData.resource;
                document.getElementById('tilePlayer').value = parsedData.player;
                document.getElementById('tileType').value = parsedData.type;
                addTile();
                speak(`${parsedData.number}ç•ªã€${resources[parsedData.resource].name}ã‚’ç™»éŒ²ã—ã¾ã—ãŸ`);
                console.log(`âœ… ç™»éŒ²æˆåŠŸ: ${parsedData.number}ç•ª ${resources[parsedData.resource].name} ${parsedData.player} ${parsedData.type}`);
            } else {
                // Show manual completion form
                showTileCompletionForm(parsedData, errors);
                speak(`${errors.join('ã¨')}ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚æ‰‹å‹•ã§é¸æŠã—ã¦ãã ã•ã„`);
            }
        }

        let tempTileData = { number: null, resource: null, player: null, type: 'settlement' };

        function showTileCompletionForm(parsedData, errors) {
            tempTileData = { ...parsedData };

            const formHtml = `
                <h3 style="color:#e74c3c;margin-bottom:10px;font-size:1.1em;">âš ï¸ éŸ³å£°å…¥åŠ›ã®è£œå®Œ</h3>

                <div style="margin:10px 0;">
                    <label style="display:block;margin-bottom:5px;font-weight:bold;font-size:0.9em;">
                        æ•°å­— ${errors.includes('æ•°å­—') ? '<span style="color:#e74c3c;">âŒ</span>' : `<span style="color:#27ae60;">âœ“ ${parsedData.number}</span>`}
                    </label>
                    <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:5px;">
                        ${[2,3,4,5,6,8,9,10,11,12].map(n =>
                            `<button onclick="setTempNumber(${n})" id="num${n}" style="padding:8px;font-size:0.9em;background:${parsedData.number === n ? '#27ae60' : '#ecf0f1'};color:${parsedData.number === n ? 'white' : '#333'};border:none;border-radius:5px;">${n}</button>`
                        ).join('')}
                    </div>
                </div>

                <div style="margin:10px 0;">
                    <label style="display:block;margin-bottom:5px;font-weight:bold;font-size:0.9em;">
                        è³‡æº ${errors.includes('è³‡æº') ? '<span style="color:#e74c3c;">âŒ</span>' : `<span style="color:#27ae60;">âœ“</span>`}
                    </label>
                    <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:5px;">
                        ${Object.entries(resources).map(([key, val]) =>
                            `<button onclick="setTempResource('${key}')" id="res${key}" style="padding:8px;font-size:1.2em;background:${parsedData.resource === key ? '#27ae60' : '#ecf0f1'};border:none;border-radius:5px;" title="${val.name}">${val.icon}</button>`
                        ).join('')}
                    </div>
                </div>

                <div style="margin:10px 0;">
                    <label style="display:block;margin-bottom:5px;font-weight:bold;font-size:0.9em;">
                        ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ ${errors.includes('ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼') ? '<span style="color:#e74c3c;">âŒ</span>' : `<span style="color:#27ae60;">âœ“</span>`}
                    </label>
                    <div style="display:grid;grid-template-columns:repeat(${Math.min(players.length, 4)},1fr);gap:5px;">
                        ${players.map((p, i) => {
                            const fixedColors = ['red', 'blue', 'white', 'orange'];
                            const colorKey = fixedColors[i % 4];
                            const colorHex = playerColors[colorKey].hex;
                            const isSelected = parsedData.player === p;
                            const textColor = colorKey === 'white' ? '#333' : 'white';
                            const opacity = isSelected ? '1' : '0.6';
                            const border = isSelected ? '3px solid #FFD700' : '2px solid rgba(0,0,0,0.1)';
                            return `<button onclick="setTempPlayer('${p}')" id="player${i}" style="padding:10px;font-size:0.85em;background:${colorHex};color:${textColor};border:${border};border-radius:5px;opacity:${opacity};font-weight:bold;">${playerColors[colorKey].name}</button>`;
                        }).join('')}
                    </div>
                </div>

                <div style="margin:10px 0;">
                    <label style="display:block;margin-bottom:5px;font-weight:bold;font-size:0.9em;">ç¨®é¡ <span style="color:#27ae60;">âœ“</span></label>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:5px;">
                        <button onclick="setTempType('settlement')" id="typeSettlement" style="padding:10px;background:${parsedData.type === 'settlement' ? '#27ae60' : '#ecf0f1'};color:${parsedData.type === 'settlement' ? 'white' : '#333'};border:none;border-radius:5px;">ğŸ  é–‹æ‹“åœ°</button>
                        <button onclick="setTempType('city')" id="typeCity" style="padding:10px;background:${parsedData.type === 'city' ? '#27ae60' : '#ecf0f1'};color:${parsedData.type === 'city' ? 'white' : '#333'};border:none;border-radius:5px;">ğŸ›ï¸ éƒ½å¸‚</button>
                    </div>
                </div>

                <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:15px;">
                    <button onclick="cancelTileCompletion()" style="background:#95a5a6;padding:12px;">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                    <button onclick="completeTileRegistration()" style="padding:12px;">ç™»éŒ²</button>
                </div>
            `;

            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);z-index:1000;display:flex;align-items:center;justify-content:center;';
            modal.innerHTML = `
                <div style="background:white;padding:20px;border-radius:15px;max-width:500px;width:90%;max-height:80vh;overflow-y:auto;">
                    ${formHtml}
                </div>
            `;
            modal.id = 'tileCompletionModal';
            document.body.appendChild(modal);
        }

        function setTempNumber(num) {
            tempTileData.number = num;
            // Update button styles
            [2,3,4,5,6,8,9,10,11,12].forEach(n => {
                const btn = document.getElementById(`num${n}`);
                if (btn) {
                    btn.style.background = n === num ? '#27ae60' : '#ecf0f1';
                    btn.style.color = n === num ? 'white' : '#333';
                }
            });
        }

        function setTempResource(resource) {
            tempTileData.resource = resource;
            Object.keys(resources).forEach(key => {
                const btn = document.getElementById(`res${key}`);
                if (btn) {
                    btn.style.background = key === resource ? '#27ae60' : '#ecf0f1';
                }
            });
        }

        function setTempPlayer(player) {
            tempTileData.player = player;
            const fixedColors = ['red', 'blue', 'white', 'orange'];
            players.forEach((p, i) => {
                const btn = document.getElementById(`player${i}`);
                if (btn) {
                    const colorKey = fixedColors[i % 4];
                    const isSelected = p === player;
                    const textColor = colorKey === 'white' ? '#333' : 'white';
                    btn.style.opacity = isSelected ? '1' : '0.6';
                    btn.style.border = isSelected ? '3px solid #FFD700' : '2px solid rgba(0,0,0,0.1)';
                    btn.style.color = textColor;
                }
            });
        }

        function setTempType(type) {
            tempTileData.type = type;
            ['settlement', 'city'].forEach(t => {
                const btn = document.getElementById(`type${t.charAt(0).toUpperCase() + t.slice(1)}`);
                if (btn) {
                    btn.style.background = t === type ? '#27ae60' : '#ecf0f1';
                    btn.style.color = t === type ? 'white' : '#333';
                }
            });
        }

        function completeTileRegistration() {
            // Validate all fields are selected
            if (!tempTileData.number || !tempTileData.resource || !tempTileData.player) {
                speak('ã™ã¹ã¦ã®é …ç›®ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }

            document.getElementById('tileNumber').value = tempTileData.number;
            document.getElementById('tileResource').value = tempTileData.resource;
            document.getElementById('tilePlayer').value = tempTileData.player;
            document.getElementById('tileType').value = tempTileData.type;

            addTile();
            speak(`${tempTileData.number}ç•ªã€${resources[tempTileData.resource].name}ã‚’ç™»éŒ²ã—ã¾ã—ãŸ`);
            cancelTileCompletion();
        }

        function cancelTileCompletion() {
            const modal = document.getElementById('tileCompletionModal');
            if (modal) modal.remove();
        }

        // previousPlayer function
        function previousPlayer() {
            currentPlayerIndex = (currentPlayerIndex - 1 + players.length) % players.length;
            updateCurrentPlayer();
            speak(`${players[currentPlayerIndex]}ã•ã‚“ã€ã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã£ã¦ãã ã•ã„ï¼`);
        }

        // Player settings
        function showPlayerSettings() {
            const fixedColors = ['red', 'blue', 'white', 'orange'];

            const settingsHtml = players.map((player, index) => {
                const colorKey = fixedColors[index % 4];
                const colorHex = playerColors[colorKey].hex;
                const colorLabel = playerColors[colorKey].name;

                return `
                    <div style="margin:15px 0;padding:10px;background:white;border-radius:8px;">
                        <div style="display:flex;gap:10px;align-items:center;">
                            <div style="width:80px;padding:10px;background:${colorHex};color:${colorKey === 'white' ? '#333' : 'white'};border-radius:5px;text-align:center;font-weight:bold;">
                                ${colorLabel}
                            </div>
                            <input type="text" id="editPlayer${index}" value="${player}" data-order="${index}"
                                   style="flex:1;padding:10px;border:2px solid ${colorHex};border-radius:5px;font-size:1em;">
                            <div style="display:flex;gap:3px;">
                                ${Array.from({length: players.length}, (_, idx) =>
                                    `<button onclick="setEditPlayerOrder(${index}, ${idx})" id="editOrderBtn${index}_${idx}"
                                     style="width:28px;height:28px;padding:0;font-size:0.8em;background:${idx === index ? '#CD853F' : '#ecf0f1'};color:${idx === index ? 'white' : '#333'};border:none;border-radius:5px;font-weight:bold;">${idx + 1}</button>`
                                ).join('')}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);z-index:1000;display:flex;align-items:center;justify-content:center;';
            modal.innerHTML = `
                <div style="background:white;padding:20px;border-radius:15px;max-width:500px;width:90%;max-height:80vh;overflow-y:auto;">
                    <h2 style="margin-bottom:15px;">âš™ï¸ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®š</h2>
                    ${settingsHtml}
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:20px;">
                        <button onclick="cancelPlayerSettings()" style="background:#95a5a6;">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                        <button onclick="savePlayerSettings()">ä¿å­˜</button>
                    </div>
                </div>
            `;
            modal.id = 'playerSettingsModal';
            document.body.appendChild(modal);
        }

        function setEditPlayerOrder(playerIndex, newOrder) {
            const inputs = document.querySelectorAll('[id^="editPlayer"]');
            const playerCount = inputs.length;

            // Get all current values
            const values = Array.from(inputs).map(input => input.value);

            // Get current order
            const currentOrder = parseInt(inputs[playerIndex].dataset.order);

            if (currentOrder === newOrder) return;

            // Swap players
            const tempValue = values[playerIndex];

            if (newOrder > currentOrder) {
                // Move down
                for (let i = playerIndex; i < newOrder; i++) {
                    values[i] = values[i + 1];
                }
            } else {
                // Move up
                for (let i = playerIndex; i > newOrder; i--) {
                    values[i] = values[i - 1];
                }
            }

            values[newOrder] = tempValue;

            // Update all inputs
            inputs.forEach((input, i) => {
                input.value = values[i];
                input.dataset.order = i;
            });

            // Update button styles
            for (let i = 0; i < playerCount; i++) {
                for (let j = 0; j < playerCount; j++) {
                    const btn = document.getElementById(`editOrderBtn${i}_${j}`);
                    if (btn) {
                        const isSelected = i === j;
                        btn.style.background = isSelected ? '#CD853F' : '#ecf0f1';
                        btn.style.color = isSelected ? 'white' : '#333';
                    }
                }
            }
        }

        function savePlayerSettings() {
            const oldPlayers = [...players];
            const fixedColors = ['red', 'blue', 'white', 'orange'];

            // Build a mapping of current display order to values
            const inputs = document.querySelectorAll('[id^="editPlayer"]');
            const playerData = Array.from(inputs).map((input, displayIndex) => ({
                name: input.value.trim() || oldPlayers[displayIndex],
                originalIndex: displayIndex
            }));

            // Sort by original index to get the new order
            const newPlayers = playerData.map(data => data.name);

            // Update players array and scores
            players = newPlayers;
            const newScores = {};
            for (let i = 0; i < newPlayers.length; i++) {
                const newPlayer = newPlayers[i];
                const oldPlayer = oldPlayers[i];
                const colorKey = fixedColors[i % 4];
                newScores[newPlayer] = {
                    ...scores[oldPlayer],
                    color: playerColors[colorKey].hex
                };
            }
            scores = newScores;

            // Update tiles with new player names
            tiles = tiles.map(tile => {
                const oldIndex = oldPlayers.indexOf(tile.player);
                if (oldIndex !== -1) {
                    return { ...tile, player: newPlayers[oldIndex] };
                }
                return tile;
            });
            saveTiles();

            // Update UI
            updatePlayerDropdown();
            updateCurrentPlayer();
            updateScoreBoard();
            renderTileList();

            cancelPlayerSettings();
            speak('ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®šã‚’æ›´æ–°ã—ã¾ã—ãŸ');
        }

        function cancelPlayerSettings() {
            const modal = document.getElementById('playerSettingsModal');
            if (modal) modal.remove();
        }

        // Tab Switching
        function switchTab(tab, event) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));

            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                // Find the tab button by matching the onclick attribute
                document.querySelectorAll('.tab').forEach(t => {
                    if (t.getAttribute('onclick').includes(tab)) {
                        t.classList.add('active');
                    }
                });
            }
            document.getElementById(tab + 'Tab').classList.add('active');

            if (tab === 'map') renderTileList();
            if (tab === 'score') updateScoreBoard();
        }

        // Initialize on load
        window.addEventListener('load', initPlayerSetup);
    </script>
</body>
</html>
